#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'

module Playr
  require 'librmpd'
  require 'term/ansicolor'
  include Term::ANSIColor

  extend Module.new { attr_accessor :out }

  def initialize
    @mpd    ||= MPD.new
    @vol    ||= Volume.new
    @format ||= Formatter.new
    @mpd.connected? || @mpd.connect
  end

  class Client
    require 'readline'
    include Playr

    Readline.completion_proc = lambda { |word|
      commands.each.grep(/^#{ Regexp.escape(word) }/)
    }

    def initialize
      super
      @print ||= Printer.new
      start! unless $TEST
    end

    def stats
      @mpd.stats.each_pair { |k,v| @print.write(k+': ' + v) }
    end

    def song?
      @mpd.current_song.each_pair { |k,v| @print.write(blue(k+": ") + v) }
    end

    def search rgx
      @mpd.songs.select { |s| s.fetch('file')[rgx] }.each { |l| @print.search(s) }
    end

    def playlist rgx=nil
      if rgx
        songs = @mpd.playlist.select { |s| s.fetch('file')[rgx] }
      else
        songs = @mpd.playlist
      end
      @print.playlist(songs)
    end

    def playlists rgx=nil
      if rgx
        songs = @mpd.playlists.select { |pl| pl[rgx] }
      else
        songs = @mpd.playlists
      end
      @print.playlists(songs)
    end

    def help
      commands
        .group_by{ |m| Client.instance_method(m) }
        .map(&:last)
        .sort { |a,b| a.to_s.size <=> b.to_s.size }
        .select { |s| @print.help(s) }
    end

    def pause;      @mpd.pause = true            end
    def continue;   @mpd.pause = false           end
    def stop;       @mpd.stop                    end
    def next;       @mpd.next                    end
    def prev;       @mpd.previous                end
    def disconnect; @mpd.disconnect              end
    def repeat;     @mpd.repeat = !@mpd.repeat?  end
    def random;     @mpd.random = !@mpd.random?  end
    def play song;  @mpd.play song               end
    def +;          @vol.+                       end
    def -;          @vol.-                       end
    def mute;       @vol.mute                    end
    def vol v;      @vol.vol(v)                  end

    alias :ls  :playlist
    alias :lsp :playlists
    alias :ps  :pause
    alias :p   :play
    alias :c   :continue
    alias :s   :search
    alias :h   :help
    alias :n   :next
    alias :r   :random
    alias :v   :vol
    alias :m   :mute
    alias :d   :disconnect

    private

    def prompt_data
      @format.song_name(@mpd.current_song.fetch('file'))
    end

    def start!
      while line = Readline.readline(@print.prompt(prompt_data)).strip
        next if line.empty?
        unless Readline::HISTORY.to_a[-1] == line
          Readline::HISTORY.push line
        end
        break if line.match(/(^quit$|^exit$|^q$)/)
        process_cmd(line)
      end
    end

    def commands
      (Client.instance_methods -
        Object.instance_methods -
        Term::ANSIColor.instance_methods)
        .select { |c| c.to_s !~ /start!/ }
    end

    def process_cmd cmd
      meth = cmd.split[0]
      args = cmd.split[1..-1]
      if commands.include?(meth.to_sym)
        begin
          self.send(meth, *args)
        rescue ArgumentError => e
          puts "Command \""+ meth +"\" "+ e.message
        end
      else
        warn "Unknown command: #{cmd.inspect}"
      end
    end
  end

  class Printer
    include Playr

    def initialize;      super                        end
    def prompt d, i='♪'; prompt_color(d +' '+ i +' ') end

    def search s
      write(blue("song: ") + @format.song_name(l.fetch('file')) +"\n" )
    end

    def playlists songs
      songs.each { |p|
        write(blue("pl: ") + p +"\n") }
    end

    def playlist songs
      write(green(@format.pl_name(@mpd.playlist.first)))
      songs.each { |l|
        write(blue("song:") + yellow(l.fetch('id'))+' '+ @format.song_name(l.fetch('file')) +"\n")
      }
    end

    def help c
      write(blue(c[0].to_s) + (c[1].nil? ? '' : (' or: ' + green(c[1].to_s))) + "\n")
    end

    private
    def prompt_color p; @vol.mute? ? red(p) : green(p) end
    def write data;     (Playr.out || $>)<< data; data end
  end

  class Volume
    def initialize
      @vol_set = 'amixer sset Master'
      @vol_get = 'amixer sget Master'
    end
    def +;     `#{@vol_set} 5%+`               end
    def -;     `#{@vol_set} 5%-`               end
    def mute;  `#{@vol_set} toggle`            end
    def mute?; `#{@vol_get}`.split.last['off'] end
    def vol v; `#{@vol_set} "#{v}"`            end
  end

  class Formatter
    def pl_name pl;     pl.fetch('file').split('/')[0..-2].join('/') end
    def song_name song; song.gsub(/(.*\/)|(\..*$)/,'')               end
  end
end

$stdout.sync = $stderr.sync = true
opts = OptionParser.new do |o|
  o.banner = "Usage: playr [OPTION] [<args>]"
  o.separator ""
  o.on("-h", "--help", "Print this help.")      { Playr.out.puts(opts) }
  o.on("-v", "--version", "Print version.")     { Playr.out.puts("0.1.1") }
  o.on("-s", "--start", "Run the mpd client.")  { Playr::Client.new }
  o.on("-t", "--tests", "run tests.")           { eval(DATA.read) }
  o.on("-d", "--debug", "Enable debug output.") { $DEBUG = true }
  o.separator ""
end

opts.parse!(ARGV)

__END__
#encoding: utf-8
$TEST = true
require 'minitest/autorun'

Playr.out = File.new('/dev/null', 'w')

class TestClient < MiniTest::Unit::TestCase
  def setup
    @c = Playr::Client.new
  end

  def test_help_should_not_incude_start_method
    require 'stringio'
    str = StringIO.new << @c.help
    refute_match /start/, str.string
    assert_match /(play|mute|vol|next)/, str.string
  end

  class TestFormatter < MiniTest::Unit::TestCase
    def setup
      @f = Playr::Formatter.new
    end

    def test_pl_name
      assert_equal 'foo/bar/baz', @f.pl_name({'file' => 'foo/bar/baz/quux.mp3'})
    end

    def test_song_name
      assert_equal 'quux', @f.song_name('foo/bar/baz/quux.mp3')
    end
  end

  class TestPrinter < MiniTest::Unit::TestCase
    def setup
      @p = Playr::Printer.new
    end

    def test_prompt
      assert_equal "\e[32mfoo ♪ \e[0m", @p.prompt("foo")
      assert_equal "\e[32mbaz ♬ \e[0m", @p.prompt("baz", "♬")
    end
  end
end

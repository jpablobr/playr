#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'

module Playr
  require 'librmpd'
  require 'term/ansicolor'
  include Term::ANSIColor

  def initialize
    @mpd    ||= MPD.new
    @vol    ||= Volume.new
    @format ||= Formatter.new
    @mpd.connected? || @mpd.connect
  end

  class Client
    require 'readline'
    include Playr

    Readline.completion_proc = lambda { |word|
      commands.each.grep(/^#{ Regexp.escape(word) }/)
    }

    def initialize
      super
      @print ||= Printer.new
      start!
    end

    def song?
      @mpd.current_song.each_pair { |k,v| puts(blue(k+": ") + v) }
    end

    def search rgx
      @mpd.songs.select { |s| s.fetch('file')[rgx] }.each { |l| @print.search(s) }
    end

    def playlist rgx=nil
      if rgx
        songs = @mpd.playlist.select { |s| s.fetch('file')[rgx] }
      else
        songs = @mpd.playlist
      end
      @print.playlist(songs)
    end

    def playlists rgx=nil
      if rgx
        songs = @mpd.playlists.select { |pl| pl[rgx] }
      else
        songs = @mpd.playlists
      end
      @print.playlists(songs)
    end

    def help
      commands
        .group_by{ |m| Client.instance_method(m) }
        .map(&:last)
        .sort { |a,b| a.to_s.size <=> b.to_s.size }
        .select { |s| @print.help(s) }
    end

    def pause;      @mpd.pause = true                               end
    def continue;   @mpd.pause = false                              end
    def stop;       @mpd.stop                                       end
    def next;       @mpd.next                                       end
    def prev;       @mpd.previous                                   end
    def disconnect; @mpd.disconnect                                 end
    def repeat;     @mpd.repeat = !@mpd.repeat?                     end
    def random;     @mpd.random = !@mpd.random?                     end
    def play song;  @mpd.play song                                  end
    def +;          @vol.+                                          end
    def -;          @vol.-                                          end
    def mute;       @vol.mute                                       end
    def vol v;      @vol.vol(v)                                     end
    def stats;      @mpd.stats.each_pair { |k,v| puts(k+': ' + v) } end

    alias :ls  :playlist
    alias :lsp :playlists
    alias :ps  :pause
    alias :p   :play
    alias :c   :continue
    alias :s   :search
    alias :h   :help
    alias :n   :next
    alias :r   :random
    alias :v   :vol
    alias :m   :mute
    alias :d   :disconnect

    private

    def prompt_data
      @format.song_name(@mpd.current_song.fetch('file'))
    end

    def start!
      while line = Readline.readline(@print.prompt(prompt_data)).strip
        next if line.empty?
        unless Readline::HISTORY.to_a[-1] == line
          Readline::HISTORY.push line
        end
        break if line.match(/(^quit$|^exit$|^q$)/)
        process_cmd(line)
      end
    end

    def commands
      (Client.instance_methods -
        Object.instance_methods -
        Term::ANSIColor.instance_methods)
        .select { |c| c.to_s !~ /start!/ }
    end

    def process_cmd cmd
      meth = cmd.split[0]
      args = cmd.split[1..-1]
      if commands.include?(meth.to_sym)
        begin
          self.send(meth, *args)
        rescue ArgumentError => e
          puts "Command \""+ meth +"\" "+ e.message
        end
      else
        warn "Unknown command: #{cmd.inspect}"
      end
    end
  end

  class Printer
    include Playr

    def initialize;      super                                   end
    def prompt d, i='â™ª'; prompt_color(d +' '+ i +' ')            end
    def playlists songs; songs.each { |p| puts blue("pl:") + p } end

    def search s
      puts(blue("song: ") + @format.song_name(l.fetch('file')))
    end

    def playlist songs
      puts green(@format.pl_name(@mpd.playlist.first))
      songs.each { |l|
        puts(blue("song:") +
        yellow(l.fetch('id'))+' '+@format.song_name(l.fetch('file')))
      }
    end

    def help cmd
      puts blue(cmd[0].to_s) +
        (cmd[1].nil? ? '' : (' or: ' + green(cmd[1].to_s)))
    end

    private

    def prompt_color p; @vol.mute? ? red(p) : green(p) end
  end

  class Volume
    def initialize
      @vol_set = 'amixer sset Master'
      @vol_get = 'amixer sget Master'
    end
    def +;     `#{@vol_set} 5%+`               end
    def -;     `#{@vol_set} 5%-`               end
    def mute;  `#{@vol_set} toggle`            end
    def mute?; `#{@vol_get}`.split.last['off'] end
    def vol v; `#{@vol_set} "#{v}"`            end
  end

  class Formatter
    def pl_name pl;     pl.fetch('file').split('/')[0..-2].join('/') end
    def song_name song; song.gsub(/(.*\/)|(\..*$)/,'')               end
  end
end


opts = OptionParser.new do |o|
  o.banner = "Usage: playr [OPTION] [<args>]"
  o.separator ""
  o.on("-h", "--help", "Print this help.")      { $stderr.puts(opts) }
  o.on("-v", "--version", "Print version.")     { $stderr.puts("0.1.1") }
  o.on("-s", "--start", "Run the mpd client.")  { Playr::Client.new }
  o.on("-t", "--tests", "run tests.")           { eval(DATA.read) }
  o.on("-d", "--debug", "Enable debug output.") { $DEBUG = true }
  o.separator ""
end

opts.parse!(ARGV)

__END__
require 'minitest/autorun'
class TestClient < MiniTest::Unit::TestCase
  def setup
    @c = Client.new
  end

  def test_should_return_an_array
    assert true, @c.commands.is_a?(Array)
  end

  def test_should_not_incude_start_or_commands_methods
    [:start!, :commands].each { |m|
      assert true, @c.commands.include?(m)
    }
  end

  def test_process_cmd_should_raise_wrong_number_of_arguments
    assert_output('"mute" does not accept arguments.') {
      @c.process_cmd("mute invalid arg")
    }
  end
end

#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'
require 'term/ansicolor'
include Term::ANSIColor

class Client
  require 'librmpd'
  require 'readline'

  Readline.completion_proc = lambda { |word|
    commands.each.grep(/^#{ Regexp.escape(word) }/)
  }

  def initialize
    @mpd = MPD.new
    @mpd.connect
    start!
  end

  def song?
    @mpd.current_song.each_pair { |k,v|
      puts(blue(k+": ") + v)
    }
  end

  def stats
    @mpd.stats.each_pair { |k,v| puts(k + ': ' + v) }
  end

  def playlist rgx=nil
    if rgx
      songs = @mpd.playlist.select { |s| s['file'][rgx] }
    else
      songs = @mpd.playlist
    end

    puts green(pl_name(@mpd.playlist.first.fetch('file')))
    songs.each { |l|
      puts(blue("song:") +
      yellow(l.fetch('id')) +
      ' ' +
      song_name(l.fetch('file')))
    }
  end

  def search rgx
    @mpd.songs.select { |s| s['file'][rgx] }
      .each { |l|
      puts(blue("song: ") +
      song_name(l.fetch('file')))
    }
  end

  def playlists rgx=nil
    if rgx
      songs = @mpd.playlists.select { |pl| pl[rgx] }
    else
      songs = @mpd.playlists
    end
    songs.each { |p| puts "#{blue("pl:")} #{p}" }
  end

  def pause;      @mpd.pause = true           end
  def continue;   @mpd.pause = false          end
  def stop;       @mpd.stop                   end
  def next;       @mpd.next                   end
  def prev;       @mpd.previous               end
  def disconnect; @mpd.disconnect             end
  def repeat;     @mpd.repeat = !@mpd.repeat? end
  def random;     @mpd.random = !@mpd.random? end
  def play song;  @mpd.play song              end
  def +;          Vol.+                       end
  def -;          Vol.-                       end
  def mute;       Vol.mute                    end
  def vol v;      Vol.vol(v)                  end

  def help
    commands
      .group_by{ |m| Client.instance_method(m)}
      .map(&:last)
      .sort { |a,b| a.to_s.size <=> b.to_s.size }
      .select { |s|
      puts blue(s[0].to_s) + (s[1].nil? ? '' : (' or: ' + green(s[1].to_s)))
    }
  end

  alias :ls  :playlist
  alias :lsp :playlists
  alias :ps  :pause
  alias :p   :play
  alias :c   :continue
  alias :s   :search
  alias :h   :help
  alias :n   :next
  alias :r   :random
  alias :v   :vol
  alias :d   :disconnect

  private

  def start!
    while line = Readline.readline(Prompt.display(prompt_data)).strip
      next if line.empty?
      unless Readline::HISTORY.to_a[-1] == line
        Readline::HISTORY.push line
      end
      break if line.match(/(^quit$|^exit$|^q$)/)
      process_cmd(line)
    end
  end

  def commands
    (Client.instance_methods -
      Object.instance_methods -
      Term::ANSIColor.instance_methods)
      .select { |c| c.to_s !~ /start!/ }
  end

  def pl_name pl
    pl.split('/')[0..-2].join('/')
  end

  def song_name song
    song.gsub(/(.*\/)|(\..*$)/,'')
  end

  def prompt_data
    song_name(@mpd.current_song.fetch('file'))
  end

  def process_cmd cmd
    meth = cmd.split[0]
    args = cmd.split[1..-1]
    if commands.include?(meth.to_sym)
      begin
        self.send(meth, *args)
      rescue ArgumentError => e
        puts "Command \"" + meth + "\" " + e.message
      end
    else
      warn "Unknown command: #{cmd.inspect}"
    end
  end
end

class Prompt
  class << self
    def display data, sign='â™ª'
      prompt_color(data + ' ' + sign + ' ')
    end

    private

    def prompt_color p
      Vol.mute? ? red(p) : green(p)
    end
  end
end

class Vol
  @@vol_set = 'amixer sset Master'
  @@vol_get = 'amixer sget Master'
  class << self
    def +;     `#{@@vol_set} 5%+`    end
    def -;     `#{@@vol_set} 5%-`    end
    def mute;  `#{@@vol_set} toggle` end
    def vol v; `#{@@vol_set} "#{v}"` end
    def mute?
      `#{@@vol_get} | awk '/Mono:/{print $6}'`['off']
    end
  end
end

opts = OptionParser.new do |o|
  o.banner = "Usage: playr [OPTION] [<args>]"
  o.separator ""
  o.on("-h", "--help", "Print this help.") {
    $stderr.puts(opts)
  }
  o.on("-v", "--version", "Print version.") {
    $stderr.puts("0.1.0")
  }
  o.on("-s", "--start", "Run the mpd client.") {
    Client.new
  }
  o.on("-t", "--tests", "run tests.") {
    eval(DATA.read)
  }
  o.on("-d", "--debug", "Enable debug output.") {
    $DEBUG = true
  }
  o.separator ""
end

opts.parse!(ARGV)

__END__
require 'minitest/autorun'
class TestClient < MiniTest::Unit::TestCase
  def setup
    @c = Client.new
  end

  def test_should_return_an_array
    assert true, @c.commands.is_a?(Array)
  end

  def test_should_not_incude_start_or_commands_methods
    [:start!, :commands].each { |m|
      assert true, @c.commands.include?(m)
    }
  end

  def test_process_cmd_should_raise_wrong_number_of_arguments
    assert_output('"mute" does not accept arguments.') {
      @c.process_cmd("mute invalid arg")
    }
  end
end
